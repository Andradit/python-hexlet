"""В проекте есть три функции по работе с массивами:

    - get()
    - index_of()
    - my_slice()

Программист, работавший на проекте до вас, недостаточно ответственно
относился к написанию тестов. Вам нужно исправить этот недочет и дописать
недостающие тесты.

Здесь поможет отчет по покрытию тестами. Работу в этом упражнении можно
выстроить следующим образом:

    1. Выполните в терминале команду make test-coverage и сгенерируйте отчет
    по покрытию кода тестами. Отчет по покрытию поможет выявить в коде места, не
    покрытые тестами.
    2. Изучите получившуюся статистику. Посмотрите, какие функции недостаточно
    покрыты тестами. Обратите внимание на столбец Missing. Здесь показано, какие
    именно строки в файлах с функциями не покрыты тестами.
    3. Изучите эти файлы в директории src/right. Разберитесь, что происходит в
    непокрытых строках. Это поможет понять, какие еще случаи нужно проверить.
    4. Допишите тесты на те функции, которые недостаточно покрыты тестами,
    опираясь на описание их работы и отчет по покрытию."""


"""Допишите необходимые тесты на функции get(), index_of() и my_slice(). Функции
работают следующим образом:

    - функция get(list, index, default = None) извлекает из списка значение
    по указанному индексу, если индекс существует. Если индекс не существует,
    она возвращает значение по умолчанию. Функция работает только с
    неотрицательными индексами:
    """

# numbers = [1, 2, 3, 4]
# get(numbers, 1)  # 2
# get(numbers, 5, 'nothing')  # 'nothing'
# get(numbers, 5)

"""Функция index_of(list, value, from_index) возвращает первый индекс, 
по которому переданное значение может быть найдено в списке или значение -1, 
если переданного значения нет:"""

# numbers = [1, 2, 3, 2, 5]
# index_of(numbers, 2)  # 1
# index_of(numbers, 7)  # -1
# index_of(numbers, 2, -3)  # 3

"""В функции используются такие аргументы:

    - list — список, в котором ведется поиск;
    - value — значение, поиск которого ведется в массиве;
    - from_index — индекс, с которого начинается поиск элемента, по умолчанию 
    равен нулю. Если значение from_index отрицательное, то оно используется 
    как смещение с конца массива.

Функция my_slice(list, begin, end) возвращает новый список, содержащий копию 
части исходного списка:"""

# numbers = [1, 2, 3, 4, 5]
# my_slice(numbers)  # [1, 2, 3, 4, 5]
# my_slice(numbers, 1, 4)  # [2, 3, 4]
# my_slice(numbers, -4, -2)  # [2, 3]
# my_slice(numbers, 7)  # []

"""В функции используются такие аргументы:

    - list — исходный список;
    - begin — индекс, по которому начинается извлечение. По умолчанию индекс 
    равен нулю. Если индекс отрицательный, begin указывает смещение от конца 
    списка;
    - end — индекс, по которому заканчивается извлечение, не включая элемент 
    с индексом end. По умолчанию равен длине исходного списка. Если индекс 
    отрицательный, end указывает смещение от конца списка.
    
Подсказки

Тестирование будет считаться успешным, если все три теста упадут на неправильных
вариантах функций. Если хотя бы один из трех тестов проходит, это значит, что
покрытие функции соответствующим тестом недостаточное. В таком случае решение
засчитано не будет"""

from functions import get_functions

func = get_functions()
get = func["get"]
index_of = func["index_of"]
my_slice = func["slice"]


def test_get():
    assert get([1, 2, 3], 1, "a") == 2
    assert get([4, 5, 6], 7, "val") == "val"
    assert get([7, 8, 9], 4) is None
    # BEGIN (write your solution here)
    "Код полностью покрыт тестами, больше тестов не требуется"
    # END


def test_index_of():
    assert index_of([2, 7, 3, 2, 4], 2) == 0
    # BEGIN (write your solution here)
    assert index_of([1, 4, 5, 8, 4], 6) == -1
    assert index_of([2, 4, 5, 4, 5], 5, -8) == 2
    assert index_of([], 2) == -1
    assert index_of([3, 4, 7, 3, 7], 3, -3) == 3
    # END


def test_slice():
    assert my_slice([1, 2, 3, 4, 5, 6], 1, 4) == [2, 3, 4]
    # BEGIN (write your solution here)
    assert my_slice([]) == []
    assert my_slice([1, 4, 3, 1, 6], -7) == [1, 4, 3, 1, 6]
    assert my_slice([3, 1, 5, 11, 4], -4, -2) == [1, 5]
    # END